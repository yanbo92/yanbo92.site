[{"content":"运行效果 项目介绍 项目地址：yanbo92/iOS-perf\n性能测试一直是APP测试的一个重要部分，而在Android上由于系统的开放特性，相关工具支持比较多，比如solopi等。但在iOS上，腾讯家的perfdog本来还是十分好用的，但收费了就有点难受，而直接用Xcode的Instruments又对Mac有刚需，很难支撑公司的测试需求。此时看到这个贴子，上手跑了几次，还挺好用的，于是就顺着思路做了下去，有了这个比较完善的项目。\n当前支持获取的性能数据包括GPU、CPU、内存、FPS、功耗、网络、温度，以及一系列手机硬件数据，并将根据需求继续新增。\n本项目基于jlintxia开源的iOS测试方案修改而来，增加动态建表，动态增加grafana面板以及docker打包环境等特性。其中iOS性能数据来源于开源工具tidevice和py-ios-device。\n注意：本项目依赖MySQL进行性能数据存储，Grafana进行数据动态展示，也就是说需要在本机或者可达的网络（比如公司局域网） 上搭建MySQL+Grafana服务，我提供了一份docker-compose.yml文件，可以使用docker快速搭建一套环境。\n相关工具 Grafana 官网\n Grafana是一个跨平台、开源的数据可视化网络应用程序平台。用户配置连接的数据源之后，Grafana可以在网络浏览器里显示数据图表和警告。该软件的企业版本提供更多的扩展功能。扩展功能通过插件的形式提供，终端用户可以自定义自己的数据面板界面以及数据请求方式。\n MySQL 官网\n MySQL原本是一个开放源码的关系数据库管理系统，原开发者为瑞典的MySQL AB公司，该公司于2008年被昇阳微系统收购。2009年，甲骨文公司收购昇阳微系统公司，MySQL成为Oracle旗下产品。\n py-ios-device 项目地址\n win，mac 跨平台方案，通过 Instruments 私有协议获取 iOS 相关性能指标数据。\n相关文章链接:https://testerhome.com/topics/27159\n tidevice 项目地址\n tidevice 是阿里的内部的一个小组用来做 iOS 自动化用的工具，通过逆向iOS通信协议，使用纯Python实现。目前淘宝和其他部分事业部已经全面使用了该技术，进行iOS应用的性能采集，UI自动化。\n注：这里的被测应用无需做任何修改，使用不再局限于Mac上。\n 使用步骤 准备工作 服务端搭建依赖docker以及docker-compose，安装指南：\n https://dockerdocs.cn/get-docker/\nhttps://dockerdocs.cn/get-started/08_using_compose/\n 运行测试依赖python3环境，安装指南：\n https://www.python.org/downloads/\n 服务端搭建 命令行运行\n1  docker -v \u0026amp;\u0026amp; docker-compose -v   如果能正常输出版本，如下，则表示docker环境正常，可以继续\n Docker version 20.10.8, build 3967b7d\ndocker-compose version 1.29.2, build 5becea4c\n 拉取镜像并启动服务：\n1  docker-compose up -d   提示：初次打开Grafana时，系统会提示你修改密码，为了方便建议不修改，即保持账号密码均为admin，否则在python运行指令中将要进行对应的传参。\n本地环境搭建 命令行执行\n1  pip install -r requirements.txt   运行命令 命令行执行：\n1 2 3 4 5 6 7 8 9 10 11  python run.py --udid=00008110-001A4D483CF2801E \\ --bundleid=com.apple.Preferences \\ --grafana_host=localhost \\ --grafana_port=30000 \\ --grafana_user=admin \\ --grafana_password=admin \\ --mysql_host=localhost \\ --mysql_port=33306 \\ --mysql_username=root \\ --mysql_password=admin \\ --mysql_db=iOSPerformance   运行参数说明 建议修改参数   \u0026ndash;bundleid：待测APP的包名，通过ideviceinstaller -l获取，默认值为com.apple.Preferences \u0026ndash;udid iPhone：手机的唯一标识符，通过 idevice_id -l 获取，客户端只连接一台手机时不用写   Grafana可选参数   \u0026ndash;grafana_host：Grafana的主机地址，只写ip，不用写Scheme，也就是http://或者https//，默认值localhost \u0026ndash;grafana_port：Grafana的端口号，默认值30000 \u0026ndash;grafana_user：Grafana的用户名，默认值admin \u0026ndash;grafana_password：Grafana的密码，默认值admin   MySQL可选参数   \u0026ndash;mysql_host：MySQL的主机地址，不用写Scheme，也就是http://或者https//，默认值localhost \u0026ndash;mysql_port：MySQL的端口号，默认值33306 \u0026ndash;mysql_user：MySQL的用户名，默认值root \u0026ndash;mysql_password：MySQL的用户名，默认值admin   数据导出 命令行执行：\n1 2 3 4 5 6  python mysql.py --runid=iphone6_1008_1532 \\ --mysql_host=localhost \\ --mysql_port=33306 \\ --mysql_username=root \\ --mysql_password=admin \\ --mysql_db=iOSPerformance   其中，--runid为必须参数，可以从显示测试数据的Grafana页面的左上角找到，通常为手机名称+月日+时分。其余Mysql参数均为可选参数，默认值与上方MySQL可选参数相同。\n心得 Docker起服务实在是太方便了，grafana做可视化也很香。也很感慨现在测试开发方面的开源环境发展起来了，有很多现成的代码可以参考。\n参考文章 PerfDog | 移动全平台性能测试分析专家\n硬货来啦！！使用纯 python 实现 Instruments 协议，跨平台 (win,mac,linux) 获取 iOS 性能数据 · TesterHome\n新工具开源！一款iOS自动化利器（附地址）\n实时可视化 iOS 性能数据 tidevice+pyiosdevice+mysql+grafana · TesterHome\n","date":"2022-01-06T00:00:00Z","image":"https://yanbo92.site/ios-perf/iOS-perf-1_huf985558f52f94ae7d6333bd201a6f5cc_710078_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/ios-perf/","title":"腾讯性能狗收费之后，我写了一款iOS性能测试工具"},{"content":"何为RSS  RSS（简易信息聚合，也叫Really Simple Syndication、聚合RSS、聚合内容），是一种消息来源格式规范，用以聚合经常发布更新数据的网站，例如博客文章、新闻、音频或视频的网摘。RSS文件（或称做摘要、网络摘要、或频更新，提供到频道）包含了全文或是节录的文字，再加上发用者所订阅之网摘布数据和授权的元数据。通常在时效性比较强的内容上使用RSS订阅能更快速获取信息，网站提供RSS输出，有利于让用户获取网站内容的最新更新。网络用户可以在客户端借助于支持RSS的聚合工具软件（例如SharpReader、NewzCrawler、FeedDemon），在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。\n 在信息碎片化严重的今天，内容平台连网页版都想砍掉，强制用户安装APP。拥有一套自己的RSS方案能让你更轻松的获得关注的信息，逃离推荐算法带来的信息茧房。\n何为Miniflux Miniflux是一个极简、快速、轻便且易于安装的Feed订阅器，有如下特性\n 支持自定义刷新和拉取时间，避免打开 RSS 时浏览过时（半小时、几个小时前）的信息 极简\u0026amp;纯粹，FreshRSS 、Tiny Tiny RSS 无论从界面还是功能，都太重了。 支持图片代理，即服务器缓存图片，默认情况下，客户端是从 RSS 源头拉取的图片，这个有特殊的场景。 支持 Fever API ，可以跨平台。 使用 WatchTower 实现 Miniflux docker 自动更新。 Web 端支持快捷键。  搭建教程  前往Heroku注册一个账号 访问anyuzu99/heroku-miniflux at main 注意确认切换到了main分支，下拉到底，点击heroku button超链接 填入APP_NAME以及ADMIN_PASSWORD等等环境变量，点击Deploy 稍等几分钟，你的域名就可以访问啦 附一份Miniflux的环境变量详解  参考 Miniflux - Minimalist and Opinionated Feed Reader\nCloud Application Platform | Heroku\nanyuzu99/heroku-miniflux: one click to deploy miniflux on heroku\n","date":"2022-03-11T00:00:00Z","image":"https://yanbo92.site/miniflux-heroku/cover_hu78651ce2218f6241db0f039b3f482add_10848_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/miniflux-heroku/","title":"使用Heroku免费搭建的Miniflux RSS服务"},{"content":"最终效果  付费证书只要仍在有效期内，账号内的设备都能不掉签使用游戏的ipa包 免费证书七天一次签名，可以用爱思助手之类的工具完成这个过程。  背景介绍  光环助手，隶属于广州加兔网络科技有限公司，是一款基于Android平台的多功能卡牌游戏助手，由光环团队制作，致力于为众手游玩家打造最优质的游戏氛围，成就最强卡牌管家。光环助手不但能节省手游玩家繁杂的游戏时间，带来更好更畅快的游戏体验；更会为玩家实时更新最新游戏资讯，搜罗大量游戏攻略以及“小编带你玩”等诸多精品栏目。\n光环修改版的游戏提供以下悬浮窗功能\n 内置攻略 内置15倍可调节加速 内置连点器，支持调节频率，次数以及保存脚本功能   操作教程 手动找出ipa地址   使用电脑或者将手机浏览器UA设置为PC进入iOS光环助手下载页\n  找到想要下载的游戏，点击下载\n  此时地址栏会暴露一个itms-services的url，这是一种无需经过App Store来分发ipa的服务\n  比如url为\n  1  itms-services://?action=download-manifest\u0026amp;url=https://ios-api.ghzs.com/install-plist/61f36f94ef0f37e259a8be73.plist   取参数中的url部分，也就是这个plist文件的地址  1  https://ios-api.ghzs.com/install-plist/61f36f94ef0f37e259a8be73.plist   直接用浏览器访问，将得到一个xml页面  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  This XML file does not appear to have any style information associated with it. The document tree is shown below. \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;items\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;assets\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;kind\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;software-package\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;url\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;https://ios-d.ghzs.com/ipa/61f36ec83feb2f4224555b8a.ipa\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;kind\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;display-image\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;url\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;https://ios-image.ghzs.com/app-icon/61f36f7d3feb2f4224555b8e.png\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;kind\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;full-size-image\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;url\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;https://ios-image.ghzs.com/app-icon/61f36f7d3feb2f4224555b8e.png\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;metadata\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;bundle-identifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.gh.snsgz2appstore3\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;bundle-version\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;1.36.89\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;kind\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;software\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;title\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;少年三国志2（安装完成后，请到设置-\u0026gt;通用-\u0026gt;描述文件与设备管理，信任企业级应用）\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt;   xml中的url即ipa下载地址的值了，再贴回地址栏，即可下载到一个被光环助手注入的游戏  重签名 麻烦移步我写的另一篇文章，有详细步骤，这里就不重复写了。\n重签名Fastbot-sub\n参考链接 光环助手官网\niOS光环助手下载页\n爱思助手官网\n签名工具Altstore\n","date":"2022-02-11T00:00:00Z","image":"https://yanbo92.site/halo-ipa/cover_hu40766f2c2bac612254123391a3204c3e_429108_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/halo-ipa/","title":"重签名解决光环助手频繁掉签问题"},{"content":"项目背景  为了对iOS崩溃日志进行进一步的分析，需要将崩溃日志中的信息拆分成不同的部分，取其中的一部分或者多个部分进行存储、对比，于是我写了一个python库将.crash文件转换成.json文件。 鉴于Apple在iOS15上已经将崩溃文件存储成类似json的格式，本库仅在iOS15以下的版本发挥作用。  操作步骤 安装crash2json 1  pip install crash2json   命令行直接运行 1  crash2json yourcrashreport.crash   其他参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  positional arguments: crash_fileoptional arguments: -h, --help show this help message and exit --binary_image_list_only parse binary_image_list to json only --crashed_thread_state_only parse crashed_thread_state to json only --diagnostic_messages_only parse diagnostic_messages to json only --exception_backtrace_only parse exception_backtrace to json only --exception_information_only parse exception_information to json only --header_only parse header to json only --other_threads_backtrace_only parse other_threads_backtrace to json only --thread0_backtrace_only parse thread0_backtrace to json only -s, --simple output a simple json with only header, exceptionInfo, diagnositcMsg, Thread0Backtrace -o OUTPUT_NAME, --output_name OUTPUT_NAME the .json file you want to save result to, no need .json suffix  源码地址 yanbo92/crash2json\n","date":"2021-12-28T00:00:00Z","image":"https://yanbo92.site/crash2json/cover_hu9c70750e0aac4e759179261a7fefa3f9_40640_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/crash2json/","title":"使用crash2json库将iOS崩溃日志解析成json文件"},{"content":"背景 Monkey测试一直是一种强度较高，性价比较高的测试手段，但在iOS平台上，工具用起来总有各种各样的苦难。今年字节跳动开源了一款自动化测试工具bytedance/Fastbot_iOS，效果非常好。但默认实现是基于纯图像识别的，有时候难免遇到一些靠图像不好处理的地方，陷入覆盖率较低的境地。但好在项目也提供了stub模式，只是上手有一定的技术门槛。之前的文章使用yololib注入fastbot-stub并重签名运行测试介绍了一种逆向手法使用fastbot-stub。本文将介绍一种从Xcode编译角度加入fastbot-stub的方法，当然，这需要app的完整代码。\n相关项目介绍 Fastbot_iOS  Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。\n mod-pbxproj  这是一个可以通过命令行修改Xcode项目依赖的python模块，便于在不使用界面的情况下增加或者删除库。\n Swift-30-Projects  这个项目是一个由30个iOS小项目组成的合集，本文使用的调试app就是项目中的04 ToDo，clone下来打包一个ipa即可。当然也可以换成其他脱了壳或者没上架Appstore的ipa包，我用这个只是因为体积比较小，打包和重签名都比较快。\n 实现原理 通过pbxproj工具向Xcode项目中添加fasbot-stub.framework动态库，并重新编译，达到让APP支持stub模式的效果。\n具体步骤 环境准备 此处需要准备好的东西：\n 一台Mac 测试APP的代码 开发者证书，以及可用的描述文件 Python环境 fastbot-stub.framework  Python环境安装pbxproj 1  sudo pip install pbxproj   fastbot-stub.framework 按照Fastbot-iOS项目的Readme打开Fastbot-iOS.xcworkspace，编译即可，完整命令：\n1 2 3 4 5  git clone git@github.com:bytedance/Fastbot_iOS.git cd Fastbot-iOS \u0026amp;\u0026amp; pod install --repo-update open Fastbot-iOS.xcworkspace   然后target选择fastbot-stub，连一台真机编译，得到产物fastbot-stub.framework\n添加动态库 同样的，我们用上一篇文章的todo项目，编写python文件如下：\n1 2 3 4 5 6 7 8 9  from pbxproj import XcodeProject from pbxproj.pbxextensions.ProjectFiles import FileOptions import time project = XcodeProject.load(\u0026#39;Swift-30-Projects/Project 04 - TodoTDD/ToDo.xcodeproj/project.pbxproj\u0026#39;) file_options = FileOptions(weak=True) project.add_file(\u0026#39;fastbot_stub.framework\u0026#39;, force=False, file_options=file_options) project.save()   修改代码中的路径，直接运行即可\n若不想通过python脚本，也可以通过纯命令行的方式，具体可以参考CLI · kronenthaler/mod-pbxproj Wiki (github.com)\n构建、打包 若没有导出ipa需求，直接在Xcode中指定手机构建即可。需要导出ipa比较麻烦，建议自行搜索。\n回到Fastbot-iOS工程，修改Fastbot-Runner的Scheme：\n1 2  dataport为9797 launchenv为stubPort=9797   再修改FastbotRunner/FastbotRunner.m，将以下代码取消注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  [fastbot_native addUIInterruptionMonitor:^CGRect(NSArray\u0026lt;XCUIElement *\u0026gt; *systemAlerts) { NSArray\u0026lt;XCUIElement*\u0026gt; *buttons = [systemAlerts.firstObject.buttons allElementsBoundByIndex]; NSInteger buttonCount = [buttons count]; CGRect btnRect = CGRectZero; if(buttonCount\u0026lt;=0) return btnRect; if(buttonCount \u0026gt; 2) { btnRect = [[buttons objectAtIndex:2] frame]; } else btnRect = [buttons.lastObject frame]; return btnRect; }];   代码大意为处理系统弹窗\n像之前运行Fastbot-iOS一样在命令行传参运行\n1  BUNDLEID=yigu.com.ToDo duration=240 throttle=300 xcodebuild test -workspace Fastbot-iOS.xcworkspace -scheme FastbotRunner -configuration Release -destination \u0026#39;platform=iOS,id=c6b0ab4fa8867c51cf1c5b6d8cd076d3957192b2\u0026#39; -only-testing:FastbotRunner/FastbotRunner/testFastbot   截取一段命令行输出：\n1 2 3 4 5  [fastbot] : visit ToDo.InputViewController,UIApplicationRotationFollowingController,UIApplicationRotationFollowingControllerNoTouches,UICompatibilityInputViewController,UIInputViewController,UIInputWindowController; visited ViewController count is: 2 [fastbot] : state visited: 30 [fastbot] : action first visited, get reward 2.336364 [fastbot] : state is saturated, get reward 0.295547 [fastbot] : got reward: 9.3110   区别在哪？区别就在于有控件信息了，如果看到类似UIInputWindowController这样的字样，恭喜你，你成功了。\n参考文章 字节跳动质量利器 \u0026ndash; 移动端智能化稳定性测试工具 Fastbot-Android/iOS 双端重磅发布上线\n奔跑吧！智能Monkey之Fastbot跨平台 \nIssue #44 · bytedance/Fastbot_iOS\n","date":"2021-11-25T00:00:00Z","image":"https://yanbo92.site/fastbot-stub-pbxproj/cover_hudd885d6f31425d9d1ba1cae39496df01_32215_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/fastbot-stub-pbxproj/","title":"使用pbxproj添加fastbot-stub.framework并运行测试"},{"content":"背景 Monkey测试一直是一种强度较高，性价比较高的测试手段，但在iOS平台上，工具用起来总有各种各样的苦难。今年字节跳动开源了一款自动化测试工具bytedance/Fastbot_iOS，效果非常好。但默认实现是基于纯图像识别的，有时候难免遇到一些靠图像不好处理的地方，陷入覆盖率较低的境地。但好在项目也提供了stub模式，只是上手有一定的技术门槛。刷了一下Github的issue，在开发者geron-cn的启发下了解到了yololib，本文将提供一种通过yololib注入方式使用fastbot-stub的方案。\n相关项目介绍 Fastbot_iOS  2019 年字节跳动 Quality Lab 在自动测试生成方面进行了比较深入的探索，并研发了针对 Android、iOS 的稳定性测试工具 Fastbot。Fastbot 的核心技术主要包括：\n智能遍历：使用基于模型的测试生成（MBT），并提供多种算法策略，以获得较高的 Activity 覆盖率及问题发现能力； 多机协同：最高支持数百台长时间多机协同遍历，同一个目标彼此协作； 个性化的专家系统：业务方可以进行多种个性化配置，比如：限定测试在指定的 Activity 运行，屏蔽测试某些场景； 模型复用：基于强化学习利用历史测试经验数据学习改进当次测试策略； 复杂用例生成：对人工用例进行模仿学习，遍历过程中混合复杂用例的组合生成； 精准定向：根据代码调用链变更自动生成针对变更场景的定向测试。\n yololib  yololib是Kim Jong Cracks（Clutch 砸壳的作者）小组搞出来的一个dylib注入工具，利用这个工具，大大方便我们修改Mach-O 文件的 Load Command。以达到注入动态库的目的。用法如下\n    yololib [binary] [dylib file]\n     LTResign  LTResign是一个用Python编写的重签名工具，这是iOS逆向绕不开的东西，但同类脚本有很多，作者通常用这个以及GQResign。\n Swift-30-Projects  这个项目是一个由30个iOS小项目组成的合集，本文使用的调试app就是项目中的04 ToDo，clone下来打包一个ipa即可。当然也可以换成其他脱了壳或者没上架Appstore的ipa包，我用这个只是因为体积比较小，打包和重签名都比较快。\n 实现原理 注入和重签名都是iOS逆向老生常谈的话题，基于这两个技术也产生了大量围绕iOS开发者证书的黑灰产，例如光环助手等。Fastbot-stub要求在App中加入fastbot-stub.framework，合入依赖重新编译打包，就是注入动态库重签名这样的方案了。\n 注入：逆向修改三方应用,让三方应用执行我们的代码，这就是代码注入，动态库注入是一种方式。其中动态库注入分为framework注入与dylib注入。此处fastbot-stub编译产物为.framework。 重签名：说白了重签名是一个偷天换日的过程，需要真机编译一个别的工程得到一份描述文件，再把需要重签名app的MachO以及frameworks都重新上一遍签名，当然，成熟的重签名脚本Github上有很多了，原理什么的有兴趣可以细看。  具体步骤 环境准备 此处需要准备好的东西：\n 一台Mac 一个砸壳后的ipa包 开发者证书，以及可用的描述文件 yololib可执行文件 LTResign可执行文件 fastbot-stub.framework  砸壳的ipa： 建议找你家开发直接打一个adhoc包，顺便要一份开发者证书，以及可用的描述文件。或者有代码权限的测试老哥们自己动手打一个，实在想用线上APP的需要砸壳，可以看看这个工具iOS App 自动砸壳平台，或者通过第三方平台下ipa包，比如爱思助手、PP助手，最折腾但能学到东西的方案：搞一台越狱的iPhone用clutch自己砸\nyololib可执行文件 1 2 3  git clone https://github.com/KJCracks/yololib cd yololib \u0026amp;\u0026amp; open yololib.xcodeproj   直接build即可，给构建产物可执行权限\n1  chmod +x yololib   建议直接放入/usr/local/bin，毕竟这个东西执行的路径有点讲究\n懒人方案：直接下载别人编译好的\n KJCracks/yololib: dylib injector for mach-o binaries (github.com)\n LTResign可执行文件 作者打包好了，可以直接下载，改权限\n1 2 3  git clone https://github.com/gltwy/LTResign cd LTResign \u0026amp;\u0026amp; chmod +x LTResign   fastbot-stub.framework 按照Fastbot-iOS项目的Readme打开Fastbot-iOS.xcworkspace，编译即可，完整命令：\n1 2 3 4 5  git clone git@github.com:bytedance/Fastbot_iOS.git cd Fastbot-iOS \u0026amp;\u0026amp; pod install --repo-update open Fastbot-iOS.xcworkspace   然后target选择fastbot-stub，连一台真机编译，得到产物fastbot-stub.framework\n动态库注入 将ipa包改名为zip包，其实下面这些步骤都可以在界面操作，看个人习惯\n1  cp ToDo.ipa ToDo.zip   解压zip，得到Payload文件夹\n1  unzip ToDo.zip   将fastbot-stub.framework复制到Payload/Todo.app/Frameworks中\n1  cp -r fastbot_stub.framework Payload/ToDo.app/Frameworks   运行yololib注入\n1  cd Payload/ToDo.app \u0026amp;\u0026amp; yololib Todo Frameworks/fastbot_stub.framework/fastbot-stub   这一步正常的输出是这样的：\n Reading binary: ToDo\n2021-11-11 22:09:37.127 yololib[20629:7615745] Thin 64bit binary!\n2021-11-11 22:09:37.128 yololib[20629:7615745] dylib size wow 88\n2021-11-11 22:09:37.128 yololib[20629:7615745] mach.ncmds 40\n2021-11-11 22:09:37.128 yololib[20629:7615745] mach.ncmds 41\n2021-11-11 22:09:37.128 yololib[20629:7615745] Patching mach_header..\n2021-11-11 22:09:37.128 yololib[20629:7615745] Attaching dylib..\n2021-11-11 22:09:37.128 yololib[20629:7615745] size 87\n2021-11-11 22:09:37.128 yololib[20629:7615745] complete!\n 这个作者打的日志十分的可爱，当你注入一个大点的库，第二行将会变成Fat Binary，胖的库\n实际上yololib做的事情是让App运行的时候加载需要注入的动态库，只是写一条链接，而不会把这个库给带进Frameworks里面，所以这两步都是必要的。\n重新把Payload打包为zip\n1  cd ../.. \u0026amp;\u0026amp; zip -r Payload.zip Payload   改名ipa\n1  mv Payload.zip Payload.ipa   此时你拥有了一个被注入的ipa包，但他装不上去手机。\n重签名 进到LTResign项目目录\n1  mv Payload.ipa LTResign \u0026amp;\u0026amp; cd LTResign   用-l参数运行ltresign获取证书id\n1  ./ltresign -l   输出类似这样子\n \\1) 24D0F12312312312312312312312300E2CC990355 \u0026ldquo;Apple Development:XXXXXXXXXXXX\u0026rdquo;\n\\2) 98D4E12312312312312312312312312312F9B013 \u0026ldquo;Apple Development: XXX XXX(XXXXXXXX)\n 这里面每一项的第一个字符串就是id了，比如24D0F12312312312312312312312300E2CC990355\n将描述文件改名为embedded.mobileprovision，也放到这个目录\n运行重签名脚本\n1  ltresign -s /Payload.ipa -d 24D0F12312312312312312312312300E2CC990355 -m embedded.mobileprovision   正常的输出会是这样结尾：\n \u0026hellip;\u0026hellip;\u0026hellip;..\nglt_tmp/glt_test/Payload/ToDo.app: replacing existing signature\n重新签名完成，可以去安装了！（2021-11-11 22:26:54）\n 此时这个目录将会生成一个重签名过的ipa glt_output.ipa\n装包测试 1  ideviceinstaller -i glt_output.ipa   回到Fastbot-iOS工程，修改Fastbot-Runner的Scheme：\n1 2  dataport为9797 launchenv为stubPort=9797   再修改FastbotRunner/FastbotRunner.m，将以下代码取消注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  [fastbot_native addUIInterruptionMonitor:^CGRect(NSArray\u0026lt;XCUIElement *\u0026gt; *systemAlerts) { NSArray\u0026lt;XCUIElement*\u0026gt; *buttons = [systemAlerts.firstObject.buttons allElementsBoundByIndex]; NSInteger buttonCount = [buttons count]; CGRect btnRect = CGRectZero; if(buttonCount\u0026lt;=0) return btnRect; if(buttonCount \u0026gt; 2) { btnRect = [[buttons objectAtIndex:2] frame]; } else btnRect = [buttons.lastObject frame]; return btnRect; }];   代码大意为处理系统弹窗\n像之前运行Fastbot-iOS一样在命令行传参运行\n1  BUNDLEID=yigu.com.ToDo duration=240 throttle=300 xcodebuild test -workspace Fastbot-iOS.xcworkspace -scheme FastbotRunner -configuration Release -destination \u0026#39;platform=iOS,id=c6b0ab4fa8867c51cf1c5b6d8cd076d3957192b2\u0026#39; -only-testing:FastbotRunner/FastbotRunner/testFastbot   截取一段命令行输出：\n1 2 3 4 5  [fastbot] : visit ToDo.InputViewController,UIApplicationRotationFollowingController,UIApplicationRotationFollowingControllerNoTouches,UICompatibilityInputViewController,UIInputViewController,UIInputWindowController; visited ViewController count is: 2 [fastbot] : state visited: 30 [fastbot] : action first visited, get reward 2.336364 [fastbot] : state is saturated, get reward 0.295547 [fastbot] : got reward: 9.3110   区别在哪？区别就在于有控件信息了，如果看到类似UIInputWindowController这样的字样，恭喜你，你成功了。\n心得 注入搞fastbot其实就是个玩，有完整代码权限正儿八经打包进去才是正道。当然很多时候这套逆向方案也够用了，文中的命令也能很好的持续集成起来。\n参考文章 字节跳动质量利器 \u0026ndash; 移动端智能化稳定性测试工具 Fastbot-Android/iOS 双端重磅发布上线\n奔跑吧！智能Monkey之Fastbot跨平台 \nIssue #44 · bytedance/Fastbot_iOS\niOS逆向工具09-yololib注入framework\n","date":"2021-11-11T00:00:00Z","image":"https://yanbo92.site/fastbot-stub-inject/cover_huccec5183e613f348bc21820d52473679_15537_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/fastbot-stub-inject/","title":"使用yololib注入fastbot-stub并重签名运行测试"},{"content":"背景 在通过Extended-Choice-Parameter插件将Jenkins参数选项动态设置为当前连接的iOS/Android手机)中，介绍了如何简单的把手机选择参数做成实时显示当前连接的设备列表，但实际使用下来，发现有以下两个小问题\n 列表只能显示手机的id，可读性极差，仍然难以避免另外去查询手机名字以对应上id iOS列表基于idevice_id实现，其底层连接依赖USB，也就是说无法做到识别无线设备  基于以上考虑，进行一次细节优化\n工具介绍 tidevice  该工具能够用于与iOS设备进行通信, 提供以下功能\n 截图 获取手机信息 ipa包的安装和卸载 根据bundleID 启动和停止应用 列出安装应用信息 模拟Xcode运行XCTest，常用的如启动WebDriverAgent测试（此方法不依赖xcodebuild) 获取指定应用性能(CPU,MEM,FPS) 文件操作 其他  支持运行在Mac，Linux，Windows上\n安装：\n1  pip3 install -U \u0026#34;tidevice[openssl]\u0026#34;    实现原理  Jenkins有许多插件支持动态参数列表，比如Extended-Choice-Parameter，又比如Active Choice，综合试用了一下选择了前者。 （一）文中只在参数的Value中编写了Groovy脚本动态获取手机id列表，而Value Description也可以通过Groovy来获取手机的名字，直接显示具体的型号 把查询手机名称的命令，也就是adb devices -l或者tidevice list写成Groovy脚本传入Extended-Choice-Parameter的Value Description里  具体实现代码 Android 如果你的手机都插在主节点master上，可以用以下代码，填入Choose Source for Value Description - Groovy Script\n1 2 3 4 5 6 7 8 9 10  String content = \u0026#34;adb devices -l\u0026#34;.execute().text String[] str; str = content.split(\u0026#39;\\n\u0026#39;); def result = []; for( String values : str ){ if(values.contains(\u0026#34;\\tdevice\u0026#34;)){ result.add(values.replaceAll(\u0026#34;\\tdevice\u0026#34;,\u0026#34;\u0026#34;)) } } result   但如果你的主节点和执行节点并不是同一个，需要在执行节点上去做动态获取，那么代码是这样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import hudson.util.RemotingDiagnostics import jenkins.model.Jenkins String agent_name = \u0026#39;节点名\u0026#39; groovy_script = \u0026#39;\u0026#39;\u0026#39; println \u0026#34;adb devices -l\u0026#34;.execute().text \u0026#39;\u0026#39;\u0026#39;.trim() def result = [] Jenkins.instance.slaves.find { agent -\u0026gt; agent.name == agent_name }.with { agent -\u0026gt; String[] str; str = RemotingDiagnostics.executeGroovy(groovy_script, agent.channel).split(\u0026#39;\\n\u0026#39;); for( String values : str ){ if(values.contains(\u0026#34;\\tdevice\u0026#34;)){ result.add(values.replaceAll(\u0026#34;\\tdevice\u0026#34;,\u0026#34;\u0026#34;)) } } } result   iOS 类似的，把adb device替换为idevice_id -l，当然也可以用tidevice list，只是要对参数做截断处理\n1 2 3 4 5 6 7 8  String content = \u0026#34;tidevice list\u0026#34;.execute().text String[] str; str = content.split(\u0026#39;\\n\u0026#39;); def result = []; for( String values : str ){ result.add(values) } result   master-slave模式代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  import hudson.util.RemotingDiagnostics import jenkins.model.Jenkins String agent_name = \u0026#39;节点名\u0026#39; groovy_script = \u0026#39;\u0026#39;\u0026#39; println \u0026#34;tidevice list\u0026#34;.execute().text \u0026#39;\u0026#39;\u0026#39;.trim() def result = [] Jenkins.instance.slaves.find { agent -\u0026gt; agent.name == agent_name }.with { agent -\u0026gt; String[] str; str = RemotingDiagnostics.executeGroovy(groovy_script, agent.channel).split(\u0026#39;\\n\u0026#39;); for( String values : str ){ result.add(values) } } result   参考文章 Jenkins 动态获取安卓设备作为参数 - 知乎 (zhihu.com)\n通过Extended-Choice-Parameter插件将Jenkins参数选项动态设置为当前连接的iOS/Android手机)\n","date":"2021-11-07T00:00:00Z","image":"https://yanbo92.site/jenkins-extended-choice-parameter-2/cover_hu63c5dde0cc6f263e8044a8d18bc03e72_272946_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/jenkins-extended-choice-parameter-2/","title":"通过Extended-Choice-Parameter插件将Jenkins参数选项动态设置为当前连接的iOS/Android手机(二)"},{"content":"背景 在自动化测试的交付、执行过程中，偶尔需要对iPhone手机的硬盘进行读写操作，比如删除相册，拷贝素材等等。本文介绍两个通过命令行操作iPhone手机硬盘的工具，分别是ifuse和tidevice。\n工具介绍 MacFuse  What is macFUSE? macFUSE allows you to extend macOS\u0026rsquo;s native file handling capabilities via third-party file systems.\nmacFUSE允许你通过第三方文件系统扩展macOS的本地文件处理能力。\nFeatures As a user, installing the macFUSE software package will let you use any third-party FUSE file system. Legacy MacFUSE file systems are supported through the optional MacFUSE compatibility layer.\nAs a developer, you can use the FUSE SDK to write numerous types of new file systems as regular user space programs. The content of these file systems can come from anywhere: from the local disk, from across the network, from memory, or any other combination of sources. Writing a file system using FUSE is orders of magnitude easier and quicker than the traditional approach of writing in-kernel file systems. Since FUSE file systems are regular applications (as opposed to kernel extensions), you have just as much flexibility and choice in programming tools, debuggers, and libraries as you have if you were developing standard macOS applications.\n作为一个用户，安装macFUSE软件包可以让你使用任何第三方FUSE文件系统。传统的MacFUSE文件系统通过可选的MacFUSE兼容层得到支持。\n作为开发者，你可以使用 FUSE SDK 来编写众多类型的新文件系统，作为常规的用户空间程序。这些文件系统的内容可以来自任何地方：来自本地磁盘，来自整个网络，来自内存，或任何其他来源的组合。使用FUSE编写文件系统比编写内核内文件系统的传统方法要容易得多，也快得多。由于 FUSE 文件系统是普通的应用程序（而不是内核扩展），你在编程工具、调试器和库方面的灵活性和选择与开发标准的 macOS 应用程序一样多。\n项目主页：osxfuse.github.io\n安装：\n1  brew install osxfuse --cask    ifuse  A fuse filesystem implementation to access the contents of iOS devices.\n一个Fuse文件系统的实现，用于访问iOS设备的内容。\nFeatures This project allows mounting various directories of an iOS device locally using the FUSE file system interface.\n这个项目允许使用[FUSE文件系统接口]在本地挂载iOS设备的各种目录。\nSome key features are:\n Media: Mount media directory of an iOS device locally Apps: Mount sandbox container or document directory of an app Jailbreak: Mount root filesystem on jailbroken devices (requires AFC2 service) Browse: Allows to retrieve a list of installed file-sharing enabled apps Implementation: Uses libimobiledevice for communication with the device  主要特性如下\n 媒体。在本地安装iOS设备的媒体目录 Apps。挂载一个应用程序的沙盒容器或文档目录。 越狱。在已越狱的设备上挂载根文件系统 （需要AFC2服务）。 浏览。允许检索已安装的支持文件共享的应用程序的列表 实施。使用[libimobiledevice]与设备进行通信  项目主页：\n安装：\n1  brew install ifuse   如果装不上，把系统时间改到2021年4月6日之前即可。但时间改了之后又会出现443:\n1  curl: (35) LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to ghcr.io:443   所以正确的操作流程是要在通过了brew校验这个包可以装之后再改回正常的时间，以通过下载包所需要的SSL校验，毫秒级操作，不过多试几次就能装上去。\n此项目依赖osxfuse，请先安装上面的osxfuse。\n tidevice  该工具能够用于与iOS设备进行通信, 提供以下功能\n 截图 获取手机信息 ipa包的安装和卸载 根据bundleID 启动和停止应用 列出安装应用信息 模拟Xcode运行XCTest，常用的如启动WebDriverAgent测试（此方法不依赖xcodebuild) 获取指定应用性能(CPU,MEM,FPS) 文件操作 其他  支持运行在Mac，Linux，Windows上\n项目主页：alibaba/taobao-iphone-device\n安装：\n1  pip3 install -U \u0026#34;tidevice[openssl]\u0026#34;    实现原理  通过阅读源码可以得知，ifuse依赖libimobiledevice，同时是基于usbmux实现的，换言之，该库只支持通过电脑usb连接手机来通信。ifuse将手机硬盘的某一部分挂载到电脑硬盘上，再通过正常的文件读写操作去控制。 而tidevice则是把instruments协议整个用python实现了一遍，这是支持无线连接手机的。并且开发者将常用文件操作封装了一层，支持 rm cat pull push stat tree rmtree mkdir ls 等操作，有点adb的味道。  具体实现代码 ifuse读写手机内存 首先新建一个mount_point目录用于挂载手机硬盘：\n1  mkdir mount_point   然后用默认参数挂载，这样将会挂载整个Media目录，可以拿到DCIM以及Downloads之类的目录内容：\n1 2 3 4 5 6  MacBook-Pro ~ % ifuse -u c6b0ab4fa8867c51cf1c5b6d8cd076d3957192b2 mount_point MacBook-Pro ~ % ls mount_point AirFair\tMediaAnalysis\tPurchases\tafk(1).zip\trd Books\tPhotoData\tRadio\tafk_screenshots DCIM\tPhotos\tRecordings\tgeneral_storage Downloads\tPublicStaging\tafk\tiTunes_Control   可以像自己电脑上的目录一样去读写，比如rm，mkdir之类的都没问题。\n卸载掉：\n1  umount mount_point   还有另一种更强力的卸载，毕竟这个库经常会卸载不掉：\n1  diskutil unmount force mount_point   再试试指定APP包名的挂载方式，此处用的是Alook浏览器com.ld.TakeBrowser：\n1 2 3 4  MacBook-Pro ~ % ifuse --documents com.ld.TakeBrowser -u c6b0ab4fa8867c51cf1c5b6d8cd076d3957192b2 mount_point MacBook-Pro ~ % ls mount_point Audios\tImages\tVideos Documents\tOthers\tZipped   这里挂载了APP的Documents目录，同样可以使用的参数还有--container\ntidevice读写手机内存 首先新建一个txt用于调试\n1  touch file.txt   类似的，查看Media下的目录：\n1 2 3 4 5 6 7 8 9  MacBook-Pro ~ % tidevice fsync ls /DCIM/ [\u0026#39;.DS_Store\u0026#39;, \u0026#39;104APPLE\u0026#39;, \u0026#39;._.DS_Store\u0026#39;, \u0026#39;103APPLE\u0026#39;, \u0026#39;102APPLE\u0026#39;, \u0026#39;.MISC\u0026#39;, \u0026#39;101APPLE\u0026#39;, \u0026#39;100APPLE\u0026#39;]   删除一张照片：\n1 2  MacBook-Pro ~ % tidevice fsync rm /DCIM/104APPLE/IMG_4334.JPG \u0026lt;AFCStatus.SUCCESS: 0\u0026gt;   操作特定的APP目录，需要使用-B参数：\nls操作：\n1 2  MacBook-Pro ~ % tidevice fsync -B com.ld.TakeBrowser ls /Documents [\u0026#39;Zipped\u0026#39;, \u0026#39;Documents\u0026#39;, \u0026#39;Videos\u0026#39;, \u0026#39;Others\u0026#39;, \u0026#39;Images\u0026#39;, \u0026#39;Audios\u0026#39;]   push操作：\n1 2  MacBook-Pro ~ % tidevice fsync -B com.ld.TakeBrowser push file.txt /Documents/ pushed to /Documents/   类似的支持的操作还有如下几个：\n1  {rm,cat,pull,stat,tree,rmtree,mkdir   使用建议 个人认为在功能没有差异的情况下，使用tidevice要比ifuse方便得多，有如下原因\n 基于Python实现，相对于ifuse使用C的实现更适合脚本集成，可以直接用python的import使用，无需使用类似os.system()这种粗暴的方式 tidevice无需挂载到本机，实际使用起来ifuse经常出现某个目录卸载失败，需要重启电脑这样的情况，会出现Input/Output Error，也就是规避掉了关闭通道异常这种风险 tidevice基于instruments实现，支持无线连接手机，当你的测试手机USB口被占用时，tidevice是唯一的选择。  ","date":"2021-11-07T00:00:00Z","image":"https://yanbo92.site/read-write-iphone-disk/cover_hu8e30f77ab5f745644f102a981b7bb12a_37562_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/read-write-iphone-disk/","title":"通过ifuse/tidevice库读写iPhone手机硬盘"},{"content":"背景 在自动化测试的交付、执行过程中，很难绕开当下大热的CI/CD工具Jenkins。而Jenkins中原生的参数类型比较单一，难以实现动态化。为了交付一些UI自动化脚本，测试工程师需要先选择执行手机、执行版本等等内容，其中选择执行手机这一步骤如果只用文本参数来实现，用户的使用场景类似这样：\n  开命令行，执行adb device 或者idevice_id -l 将手机id粘贴到Jenkins执行参数中，运行   本文提供一种一步到位的选择参数实现。\n工具介绍 Jenkins  Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行（这个比较抽象，暂且写上，不做解释）。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。\n Extended-Choice-Parameter  Extended-Choice-Parameter是一款Jenkins插件，主要功能为对选择参数进行扩展，用于实现多选参数、实现选项动态获取等更强大的功能\n Groovy  Groovy是一种基于JVM（Java虚拟机）的敏捷开发语言，它结合了Python、Ruby和Smalltalk的许多强大的特性，Groovy 代码能够与 Java 代码很好地结合，也能用于扩展现有代码。由于其运行在 JVM 上的特性，Groovy也可以使用其他非Java语言编写的库。\n 实现原理  Jenkins有许多插件支持动态参数列表，比如Extended-Choice-Parameter，又比如Active Choice，综合试用了一下选择了前者。 把查询手机id的命令，也就是adb devices或者idevice_id -l写成Groovy脚本传入Extended-Choice-Parameter的Value里  具体实现代码 Android 如果你的手机都插在主节点master上，可以用以下代码，填入Choose Source for Value - Groovy Script\n1 2 3 4 5 6 7 8 9 10  String content = \u0026#34;adb devices\u0026#34;.execute().text String[] str; str = content.split(\u0026#39;\\n\u0026#39;); def result = []; for( String values : str ){ if(values.contains(\u0026#34;\\tdevice\u0026#34;)){ result.add(values.replaceAll(\u0026#34;\\tdevice\u0026#34;,\u0026#34;\u0026#34;)) } } result   但如果你的主节点和执行节点并不是同一个，需要在执行节点上去做动态获取，那么代码是这样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  import hudson.util.RemotingDiagnostics import jenkins.model.Jenkins String agent_name = \u0026#39;节点名\u0026#39; groovy_script = \u0026#39;\u0026#39;\u0026#39; println \u0026#34;adb devices\u0026#34;.execute().text \u0026#39;\u0026#39;\u0026#39;.trim() def result = [] Jenkins.instance.slaves.find { agent -\u0026gt; agent.name == agent_name }.with { agent -\u0026gt; String[] str; str = RemotingDiagnostics.executeGroovy(groovy_script, agent.channel).split(\u0026#39;\\n\u0026#39;); for( String values : str ){ if(values.contains(\u0026#34;\\tdevice\u0026#34;)){ result.add(values.replaceAll(\u0026#34;\\tdevice\u0026#34;,\u0026#34;\u0026#34;)) } } } result   iOS 类似的，把adb device替换为idevice_id -l，当然也可以用tidevice list，只是要对参数做截断处理\n1 2 3 4 5 6 7 8  String content = \u0026#34;idevice_id -l\u0026#34;.execute().text String[] str; str = content.split(\u0026#39;\\n\u0026#39;); def result = []; for( String values : str ){ result.add(values.replaceAll(\u0026#34;\\tdevice\u0026#34;,\u0026#34;\u0026#34;)) } result   参考文章 Jenkins 动态获取安卓设备作为参数 - 知乎 (zhihu.com)\n","date":"2021-11-01T00:00:00Z","image":"https://yanbo92.site/jenkins-extended-choice-parameter/cover_hu970871ad5171085453ce87675217b77b_219179_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/jenkins-extended-choice-parameter/","title":"通过Extended-Choice-Parameter插件将Jenkins参数选项动态设置为当前连接的iOS/Android手机"},{"content":"最终效果  通过特定的接口直接往iPhone上发送通知 支持链接转跳 支持一键复制 支持自定义图标  项目介绍  传统通知方式例如邮件、聊天软件来做自动提醒还是略微麻烦。\nBark提供http接口，简单调用即可给自己的iPhone发送推送。\n可以为你带来非常及时、稳定可靠、隐私安全的推送服务。\nBark不会消耗设备的电量， 核心功能是基于系统推送服务与推送扩展，APP本体并不需要运行。\nBark可以非常可靠的保证你的隐私安全。\n你可以手动或通过docker在自己的服务器上运行Bark服务端，或者自行实现服务端。\n数据将在 你的服务器-系统推送服务器-你的设备 之间传输，确保任何推送信息都不会被泄漏。\nAPP 是通过 Github Action 编译上传，保证你使用的APP版本是由开源代码编译，未经任何人修改（验证方法请在 APP 内查看)。\nBark保存在本地的通知消息历史也非常安全。\n通过 NotificationServiceExtension 扩展，在收到推送时将推送信息保存在本地，不会经过其他任何设备。\n历史记录仅由个人iCloud私有库进行同步，可以确保你产生的任何通知，将只留在你的设备与你的iCloud中\n 相关链接 项目主页\n作者博客\nApp Store\n使用说明 内容推送  打开APP，复制测试URL  修改内容，请求这个URL  1 2 3 4 5 6 7 8 9 10 11  可以发 get 或者 post 请求 ，请求成功会立即收到推送 URL 组成: 第一个部分是 key , 之后有三个匹配 /:key/:body /:key/:title/:body /:key/:category/:title/:body title 推送标题 比 body 字号粗一点 body 推送内容 换行请使用换行符 \u0026#39;\\n\u0026#39; category 另外的功能占用的字段，还没开放 忽略就行 post 请求 参数名也是上面这些   复制参数 收到推送时下拉推送（或在通知中心左滑查看推送）有一个复制按钮，点击即可复制推送内容。\n1 2  //将复制“验证码是9527” https://api.day.app/yourkey/验证码是9527   携带参数 automaticallyCopy=1， 收到推送时，推送内容会自动复制到粘贴板（如发现不能自动复制，可尝试重启一下手机）\n1 2  //自动复制 “验证码是9527” 到粘贴板 https://api.day.app/yourkey/验证码是9527?automaticallyCopy=1   携带copy参数， 则上面两种复制操作，将只复制copy参数的值\n1 2  //自动复制 “9527” 到粘贴板 https://api.day.app/yourkey/验证码是9527?automaticallyCopy=1\u0026amp;copy=9527   其他参数  url  1 2  // 点击推送将跳转到url的地址（发送时，URL参数需要编码） https://api.day.app/yourkey/百度网址?url=https://www.baidu.com    isArchive  1 2 3  // 指定是否需要保存推送信息到历史记录，1 为保存，其他值为不保存。 // 如果不指定这个参数，推送信息将按照APP内设置来决定是否保存。 https://api.day.app/yourkey/需要保存的推送?isArchive=1    group  1 2  // 指定推送消息分组，可在历史记录中按分组查看推送。 https://api.day.app/yourkey/需要分组的推送?group=groupName    icon (仅 iOS15 或以上支持）  1 2  // 指定推送消息图标 https://api.day.app/yourkey/需要自定义图标的推送?icon=http://day.app/assets/images/avatar.jpg    时效性通知  1 2 3 4 5 6 7  // 设置时效性通知 https://api.day.app/yourkey/时效性通知?level=timeSensitive // 可选参数值 // active：不设置时的默认值，系统会立即亮屏显示通知。 // timeSensitive：时效性通知，可在专注状态下显示通知。 // passive：仅将通知添加到通知列表，不会亮屏提醒   ","date":"2021-10-31T00:00:00Z","image":"https://yanbo92.site/bark/cover_hu005522ada94621179bddb74610837b8a_13743_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/bark/","title":"调用接口推送消息到你iPhone——iOS开源项目Bark"},{"content":"Auto.JS介绍  Auto.js Pro是什么 一个在Android、鸿蒙平台编写、运行JavaScript代码的集成开发环境，包括代码补全的编辑器、单步调试、图形化设计，可构建为独立apk应用，也可连接电脑开发。\nAuto.js Pro能做什么 创建自动化工具、效率工具、优美界面、小应用，诸如早晨自动签到、处理文件为excel、图片批量处理、机器人、自动化测试、搭建服务器等，或解放双手，或学习编程，或制作应用。\n为什么选择Auto.js Pro 完善的文档和示例、丰富的API、增强的加密、活跃的更新，\u0008用JavaScript连接Java、Android、Node.js的生态。\n 注：Auto.JS与Auto.JS Pro的区别在于，前者是免费、开源的，但是已经停更多年，后者需要付费，但仍在持续更新，提供更多的功能。Auto.js 开源版本已不再维护(原因参见Auto.js Pro FAQ)，后续将只维护Auto.js Pro专业版。\n官网链接 Auto.JS\nAuto.JS Pro\n杀死APP具体实现 实现原理  调用engines.all()方法获取当前正在运行的所有引擎对象（返回对象数组） 再调用engines.myEngine()方法获取当前正在前台运行这个方法的对象（返回单个对象） 进行对象比对后再调用engine.forceStop()方法杀死非当前引擎对象 该方法能避免用户反复运行脚本，导致脚本互相干扰、资源占用等情况  完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14  function kill_scripts() { allNgs = engines.all() myNg = engines.myEngine() for (var i = 0; i \u0026lt; allNgs.length; ++i) { if (!(allNgs[i] === myNg)) { allNgs[i].forceStop() } } } kill_scripts()   ","date":"2021-10-28T00:00:00Z","image":"https://yanbo92.site/autojs-kill-scripts/cover_huf8455661e60541679509d6723cfd1c65_191882_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/autojs-kill-scripts/","title":"Auto.JS中杀死其他脚本的方法"},{"content":"Auto.JS介绍  Auto.js Pro是什么 一个在Android、鸿蒙平台编写、运行JavaScript代码的集成开发环境，包括代码补全的编辑器、单步调试、图形化设计，可构建为独立apk应用，也可连接电脑开发。\nAuto.js Pro能做什么 创建自动化工具、效率工具、优美界面、小应用，诸如早晨自动签到、处理文件为excel、图片批量处理、机器人、自动化测试、搭建服务器等，或解放双手，或学习编程，或制作应用。\n为什么选择Auto.js Pro 完善的文档和示例、丰富的API、增强的加密、活跃的更新，\u0008用JavaScript连接Java、Android、Node.js的生态。\n 注：Auto.JS与Auto.JS Pro的区别在于，前者是免费、开源的，但是已经停更多年，后者需要付费，但仍在持续更新，提供更多的功能。Auto.js 开源版本已不再维护(原因参见Auto.js Pro FAQ)，后续将只维护Auto.js Pro专业版。\n官网链接 Auto.JS\nAuto.JS Pro\n杀死APP具体实现 实现原理  调用openAppSetting(packageName)方法打开系统设置中对应APP的设置页 通过控件操作点击强制停止，确认等按钮，达到杀死APP的目的 该方法巧妙的规避了通过adb shell kill或者 adb shell am force-stop方法带来的权限问题  完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  function kill_app(packageName) { var name = getPackageName(packageName); if (!name) { if (getAppName(packageName)) { name = packageName; } else { return false; } } app.openAppSetting(name); text(app.getAppName(name)).waitFor(); let is_sure = textMatches(/(.*强.*|.*停.*|.*结.*|.*行.*)/).findOne(); if (is_sure.enabled()) { textMatches(/(.*强.*|.*停.*|.*结.*|.*行.*)/).findOne().click(); textMatches(/(.*确.*|.*定.*)/).findOne().click(); log(app.getAppName(name) + \u0026#34;应用已被关闭\u0026#34;); sleep(1000); back(); } else { log(app.getAppName(name) + \u0026#34;应用不能被正常关闭或不在后台运行\u0026#34;); back(); } } kill_app(\u0026#39;微信\u0026#39;)   ","date":"2021-10-25T00:00:00Z","image":"https://yanbo92.site/autojs-kill-app/cover_huf8455661e60541679509d6723cfd1c65_191882_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/autojs-kill-app/","title":"Auto.JS中免Root杀死APP的巧妙方法"},{"content":"最终效果 浏览器、命令行低延迟访问github，刷项目、拉依赖访问正常\n项目介绍  FastGithub是一款github加速神器，解决github打不开、用户头像无法加载、releases无法上传下载、git-clone、git-pull、git-push失败等问题。\n 项目主页 FastGithub\n加速实现原理  windows  客户端访问https://github.com 客户端向dns查询github.com的ip，FastGithub拦截dns数据包并伪造解析结果为127.0.0.1 客户端请求到FastGithub的https://127.0.0.1:443 FastGithub使用fastgithub.cer颁发服务器证书给客户端 FastGithub查询和计算github.com最快的ip FastGithub与github.com进行无sni的tls连接 FastGithub将请求反向代理到https://github.com  linux/osx  客户端访问https://github.com 客户端使用fagithub的代理端口38457代理请求 FastGithub将代理的流量请求到自身的反向代理服务 FastGithub使用fastgithub.cer颁发服务器证书给客户端 FastGithub查询和计算github.com最快的ip FastGithub与github.com进行无sni的tls连接 FastGithub将请求反向代理到https://github.com   配置步骤 下载、解压文件 下载链接中的最新osx压缩包，命名类似fastgithub_osx-x64.zip\nReleases\n安装证书  解压后，双击运行Unix可执行文件fastgithub，同目录下将会生成cert目录 双击cert目录中的fastgithub.cer证书文件，并设置为信任方式为始终信任  设置代理 系统代理\n  打开设置-网络，选择使用的网络模式，比如wifi\n  点击左下角黄色锁，解锁\n  点击高级，代理，勾选自动代理配置\n  填入URL：http://127.0.0.1:38457\n  点击右下角应用\n  命令行代理环境变量\n 编辑~/.zshrc或者~/.bashrc，这取决于你的shell用哪种 加入一行：  1  export https_proxy=http://127.0.0.1:38457 http_proxy=http://127.0.0.1:38457    保存，并运行source ~/.zshrc或者source ~/.bashrc  配置开机自启  打开设置-用户与群组，选择用户 选择登陆项，点击+符号，选择fastgithub的Unix可执行文件，并勾选隐藏。  ","date":"2021-10-24T00:00:00Z","image":"https://yanbo92.site/fastgithub/cover_hueda3ebb99c1fa3a5f32b75cbd7fabda1_194921_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/fastgithub/","title":"Mac电脑使用FastGithub加速并配置命令行代理、开机自动启动"},{"content":"项目背景  由于调试插件冲突需要，经常重装Sonar，但插件又要重新安装，于是自定义一个Dockerfile来预装我需要的插件，做成镜像 另外，Sonar自带的数据库较弱，官方只建议调试使用，并且会永远有一个Banner提示你更换数据库，所以使用docker-compose把Sonar和PostgreSQL数据库的镜像编排起来，一起搭建 默认环境：已安装docker和docker-compose  操作步骤 新建项目目录 1  mkdir sonar_postgres \u0026amp;\u0026amp; cd sonar_postgres   新建Dockerfile文件和docker-compose文件 1  touch Dockerfile \u0026amp;\u0026amp; touch docker-compose-yml   编辑Dockerfile，预装Sonar插件 Dockerfile文件内容：\n1 2 3 4  FROMsonarqube:8.9-communityRUN wget -P /opt/sonarqube/extensions/plugins/ https://github.com/xuhuisheng/sonar-l10n-zh/releases/download/sonar-l10n-zh-plugin-8.9/sonar-l10n-zh-plugin-8.9.jarRUN wget -P /opt/sonarqube/extensions/plugins/ https://github.com/tal-tech/sonar-swift/releases/download/1.5.1/tal-sonar-swift-plugin-1.5.1.jarRUN wget -P /opt/sonarqube/extensions/plugins/ https://github.com/detekt/sonar-kotlin/releases/download/2.3.0/sonar-detekt-2.3.0.jar  使用最新版本的Sonar Community版，安装中文插件、swift插件以及kotlin插件。此处使用最粗暴的下载、拷贝jar文件的安装方法。通过挂载存储也可以实现相同的功能。\n根据Dockerfile构建镜像 1  docker build -t sonarqube_plugins:v1 .   此处-t后面的第一个参数为镜像名字以及版本，第二个参数.为Dockerfile所在目录，下面使用docker-compose时将会用到镜像名字以及版本\n使用docker-compose编排镜像 编辑文件docker-compose.yml：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  version: \u0026#34;3\u0026#34; services: sonarqube: image: sonarqube_plugins:v1 expose: - 9000 ports: - \u0026#34;9000:9000\u0026#34; networks: - sonarnet environment: - sonar.jdbc.url=jdbc:postgresql://db:5432/sonar - sonar.jdbc.username=sonar - sonar.jdbc.password=sonar db: image: postgres networks: - sonarnet environment: - POSTGRES_USER=sonar - POSTGRES_PASSWORD=sonar networks: sonarnet:   启动容器 1  docker-compose up -d   此时在浏览器访问localhost:9000就能看到Sonar了\n","date":"2021-10-24T00:00:00Z","image":"https://yanbo92.site/sonar-docker/cover_hu884a5e4f3fa9446421b4fa3c4d508b29_119360_120x120_fill_box_smart1_3.png","permalink":"https://yanbo92.site/sonar-docker/","title":"使用Dockerfile和docker-compose搭建Sonar+PostgreSQL代码扫描服务"}]